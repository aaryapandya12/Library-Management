<div class="card mt-4">
  <div class="card-header bg-#333 text-black">
    <h4 class="mb-0"><i class="bi bi-book me-2"></i>Books Issued</h4>
  </div>
  <div class="card-body">
    <div class="d-flex justify-content-between mb-4">
      <div>
        <select
          id="statusFilter"
          class="form-select shadow-sm"
          style="width: 200px"
        >
          <option value="all">All Status</option>
          <option value="returned">Returned</option>
          <option value="borrowed">Borrowed</option>
        </select>
      </div>

      <div class="input-group" style="width: 300px">
        <span class="input-group-text bg-light"
          ><i class="bi bi-search"></i
        ></span>
        <input
          type="text"
          id="searchInput"
          class="form-control shadow-sm"
          placeholder="Search books..."
        />
      </div>
    </div>

    <div class="table-responsive rounded-3 border">
      <table class="table table-striped table-hover mb-0">
        <thead class="table-dark">
          <tr>
            <th class="ps-4">Record ID</th>
            <th>Book Title</th>
            <th>Borrower</th>
            <th>Borrow Date</th>
            <th>Due Date</th>
            <th>Status</th>
            <th class="pe-4 text-end">Actions</th>
          </tr>
        </thead>
        <tbody id="issuedBooksTableBody" class="border-top-0"></tbody>
      </table>
    </div>
  </div>
</div>

<script>
  const borrowRecordsApiUrl = "http://localhost:3000/borrowRecords";
  const booksApiUrl = "http://localhost:3000/books";
  const usersApiUrl = "http://localhost:3000/users";

  let allRecords = [];
  let sortDirection = 1;
  let currentSortColumn = null;

  const statusFilter = document.getElementById("statusFilter");
  const searchInput = document.getElementById("searchInput");
  const issuedBooksTableBody = document.getElementById("issuedBooksTableBody");

  Promise.all([fetchBorrowRecords(), fetchBooks(), fetchUsers()]).then(() => {
    renderIssuedBooks();
    setupEventListeners();
  });

  function fetchBorrowRecords() {
    return fetch(borrowRecordsApiUrl)
      .then((res) => {
        if (!res.ok) throw new Error("Failed to fetch borrow records");
        return res.json();
      })
      .then((data) => {
        allRecords = Array.isArray(data) ? data : [];
      })
      .catch((error) => {
        console.error("Error fetching borrow records:", error);
        showAlert("Failed to load borrow records. Please try again.", "danger");
      });
  }

  function fetchBooks() {
    return fetch(booksApiUrl)
      .then((res) => {
        if (!res.ok) throw new Error("Failed to fetch books");
        return res.json();
      })
      .then((data) => {
        window.booksData = Array.isArray(data) ? data : [];
      })
      .catch((error) => {
        console.error("Error fetching books:", error);
      });
  }

  function fetchUsers() {
    return fetch(usersApiUrl)
      .then((res) => {
        if (!res.ok) throw new Error("Failed to fetch users");
        return res.json();
      })
      .then((data) => {
        window.usersData = Array.isArray(data) ? data : [];
      })
      .catch((error) => {
        console.error("Error fetching users:", error);
      });
  }

  function setupEventListeners() {
    statusFilter.addEventListener("change", renderIssuedBooks);
    searchInput.addEventListener("input", renderIssuedBooks);

    document.querySelectorAll("th[data-sortable]").forEach((header) => {
      header.addEventListener("click", () => {
        const column = header.getAttribute("data-sortable");
        if (currentSortColumn === column) {
          sortDirection *= -1;
        } else {
          currentSortColumn = column;
          sortDirection = 1;
        }
        renderIssuedBooks();
      });
    });
  }

  function getBookTitle(bookId) {
    const book = window.booksData.find(
      (b) => b.BookID == bookId || b.id == bookId
    );
    return book ? book.Title : "Unknown Book";
  }

  function getUserName(userId) {
    const user = window.usersData.find(
      (u) => u.UserID == userId || u.id == userId
    );
    return user ? user.Name : "Unknown User";
  }

  function renderIssuedBooks() {
    const statusFilterValue = statusFilter.value;
    const searchTerm = searchInput.value.toLowerCase();

    let filteredRecords = allRecords.filter((record) => {
      const matchesStatus =
        statusFilterValue === "all" ||
        record.Status.toLowerCase() === statusFilterValue;

      const bookTitle = getBookTitle(record.BookID).toLowerCase();
      const userName = getUserName(record.UserID).toLowerCase();

      const matchesSearch =
        bookTitle.includes(searchTerm) ||
        userName.includes(searchTerm) ||
        record.RecordID.toString().includes(searchTerm);

      return matchesStatus && matchesSearch;
    });

    if (currentSortColumn) {
      filteredRecords.sort((a, b) => {
        let aValue, bValue;

        switch (currentSortColumn) {
          case "title":
            aValue = getBookTitle(a.BookID);
            bValue = getBookTitle(b.BookID);
            return aValue.localeCompare(bValue) * sortDirection;
          case "borrower":
            aValue = getUserName(a.UserID);
            bValue = getUserName(b.UserID);
            return aValue.localeCompare(bValue) * sortDirection;
          case "borrowDate":
            return (
              (new Date(a.BorrowDate) - new Date(b.BorrowDate)) * sortDirection
            );
          case "dueDate":
            return (new Date(a.DueDate) - new Date(b.DueDate)) * sortDirection;
          case "status":
            return a.Status.localeCompare(b.Status) * sortDirection;
          default:
            return 0;
        }
      });
    }

    issuedBooksTableBody.innerHTML = filteredRecords
      .map(
        (record) => `
      <tr>
        <td class="ps-4">${record.RecordID}</td>
        <td>${getBookTitle(record.BookID)}</td>
        <td>${getUserName(record.UserID)}</td>
        <td>${formatDate(record.BorrowDate)}</td>
        <td>${formatDate(record.DueDate)}</td>
        <td>
          <span class="badge ${
            record.Status === "returned" ? "bg-success" : "bg-warning text-dark"
          }">
            ${record.Status}
          </span>
        </td>
        <td class="pe-4 text-end">
          ${
            record.Status === "borrowed"
              ? `
            <button class="btn btn-sm btn-outline-success me-2 return-btn" data-id="${record.RecordID}">
              <i class="bi bi-check-circle me-1"></i>Mark Returned
            </button>
          `
              : ""
          }
          <button class="btn btn-sm btn-outline-danger delete-btn" data-id="${
            record.RecordID
          }">
            <i class="bi bi-trash me-1"></i>Delete
          </button>
        </td>
      </tr>
    `
      )
      .join("");

    document.querySelectorAll(".return-btn").forEach((btn) => {
      btn.addEventListener("click", () => markAsReturned(btn.dataset.id));
    });

    document.querySelectorAll(".delete-btn").forEach((btn) => {
      btn.addEventListener("click", () => deleteRecord(btn.dataset.id));
    });
  }

  function formatDate(dateString) {
    if (!dateString) return "N/A";
    const date = new Date(dateString);
    return date.toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
    });
  }

  function markAsReturned(recordId) {
    if (confirm("Are you sure you want to mark this book as returned?")) {
      const record = allRecords.find((r) => r.RecordID == recordId);
      if (!record) return;

      fetch(`${borrowRecordsApiUrl}/${recordId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          Status: "returned",
          ReturnDate: new Date().toISOString().split("T")[0],
        }),
      })
        .then((res) => {
          if (!res.ok) throw new Error("Update failed");
          return fetchBorrowRecords();
        })
        .then(() => {
          renderIssuedBooks();
          showAlert("Book marked as returned successfully", "success");

          const book = window.booksData.find(
            (b) => b.BookID == record.BookID || b.id == record.BookID
          );
          if (book) {
            fetch(`${booksApiUrl}/${book.id}`, {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                AvailableCopies: parseInt(book.AvailableCopies) + 1,
              }),
            });
          }
        })
        .catch((error) => {
          console.error("Error updating record:", error);
          showAlert("Failed to update record", "danger");
        });
    }
  }

  function deleteRecord(recordId) {
    if (confirm("Are you sure you want to delete this record?")) {
      fetch(`${borrowRecordsApiUrl}/${recordId}`, {
        method: "DELETE",
      })
        .then((res) => {
          if (!res.ok) throw new Error("Delete failed");
          return fetchBorrowRecords();
        })
        .then(() => {
          renderIssuedBooks();
          showAlert("Record deleted successfully", "success");
        })
        .catch((error) => {
          console.error("Error deleting record:", error);
          showAlert("Failed to delete record", "danger");
        });
    }
  }

  function showAlert(message, type) {
    const existingAlert = document.querySelector(".alert");
    if (existingAlert) existingAlert.remove();

    const alertDiv = document.createElement("div");
    alertDiv.className = `alert alert-${type} alert-dismissible fade show fixed-top mx-auto mt-3`;
    alertDiv.style.maxWidth = "500px";
    alertDiv.style.zIndex = "1100";
    alertDiv.role = "alert";
    alertDiv.innerHTML = `
      ${message}
      <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    `;

    document.body.appendChild(alertDiv);
  }
</script>
