<div class="card mt-4">
  <div class="card-header bg-#333 text-black">
    <h4 class="mb-0"><i class="bi bi-book me-2"></i>Books Issued</h4>
  </div>
  <div class="card-body">
    <div class="d-flex justify-content-between mb-4">
      <div>
        <select
          id="statusFilter"
          class="form-select shadow-sm"
          style="width: 200px"
        >
          <option value="all">All Status</option>
          <option value="pending">Pending</option>
          <option value="borrowed">Borrowed</option>
          <option value="returned">Returned</option>
        </select>
      </div>

      <div class="input-group" style="width: 300px">
        <span class="input-group-text bg-light"
          ><i class="bi bi-search"></i
        ></span>
        <input
          type="text"
          id="searchInput"
          class="form-control shadow-sm"
          placeholder="Search books..."
        />
      </div>
    </div>

    <div class="table-responsive rounded-3 border">
      <table class="table table-striped table-hover mb-0">
        <thead class="table-white">
          <tr>
            <th class="ps-4">Record ID</th>
            <th>Book Title</th>
            <th>Borrower</th>
            <th>Borrow Date</th>
            <th>Due Date</th>
            <th>Status</th>
            <th class="pe-4 text-end">Actions</th>
          </tr>
        </thead>
        <tbody id="issuedBooksTableBody" class="border-top-0"></tbody>
      </table>
    </div>
    <nav class="mt-4 d-flex justify-content-end">
      <ul class="pagination" id="paginationContainer"></ul>
    </nav>
  </div>
</div>

<script src="../js/script.js"></script>

<script>
  const borrowRecordsApiUrl = "http://localhost:8080/api/borrowRecords";
  const booksApiUrl = "http://localhost:8080/api/books";
  const usersApiUrl2 = "http://localhost:8080/api/users";

  let allRecords = [];
  let sortDirection = 1;
  let currentSortColumn = null;
  let currentPage = 0;
  let totalPages = 0;

  const statusFilter = document.getElementById("statusFilter");
  const searchInput = document.getElementById("searchInput");
  const issuedBooksTableBody = document.getElementById("issuedBooksTableBody");

  Promise.all([fetchBorrowRecords(), fetchBooks(), fetchUsers()]).then(() => {
    renderIssuedBooks();
    setupEventListeners();
    fetchTotalRecords();
  });

  function fetchBorrowRecords(page = 0) {
    currentPage = page;
    fetch(`${borrowRecordsApiUrl}/pageNum/${page}`, {
      headers: {
        Authorization: getAuthorization(),
      },
    })
      .then((res) => res.json())
      .then((data) => {
        allRecords = data || [];
        renderIssuedBooks(allRecords);
        updatePagination();
      })
      .catch((error) => console.error("Error fetching records:", error));
  }

  function fetchTotalRecords() {
    fetch(`${borrowRecordsApiUrl}/total`, {
      headers: {
        Authorization: getAuthorization(),
      },
    })
      .then((res) => res.json())
      .then((count) => {
        totalPages = Math.ceil(count / 10);
        updatePagination();
      })
      .catch((err) => console.error("Error fetching total records:", err));
  }

  function updatePagination() {
    const paginationContainer = document.getElementById("paginationContainer");
    paginationContainer.innerHTML = "";

    for (let i = 0; i < totalPages; i++) {
      const li = document.createElement("li");
      li.className = `page-item ${i === currentPage ? "active" : ""}`;
      li.innerHTML = `<button class="page-link">${i + 1}</button>`;
      li.addEventListener("click", () => fetchAndRenderAuthors(i));
      paginationContainer.appendChild(li);
    }
  }

  function fetchBooks() {
    return fetch(booksApiUrl, {
      headers: {
        Authorization: getAuthorization(),
      },
    })
      .then((res) => {
        if (!res.ok) throw new Error("Failed to fetch books");
        return res.json();
      })
      .then((data) => {
        window.booksData = Array.isArray(data) ? data : [];
      })
      .catch((error) => {
        console.error("Error fetching books:", error);
      });
  }

  function fetchUsers() {
    return fetch(usersApiUrl2, {
      headers: {
        Authorization: getAuthorization(),
      },
    })
      .then((res) => {
        if (!res.ok) throw new Error("Failed to fetch users");
        return res.json();
      })
      .then((data) => {
        window.allUsersData = Array.isArray(data) ? data : [];
        window.usersData = window.allUsersData.filter(
          (user) => user.userType && user.userType.toLowerCase() === "user"
        );
      })
      .catch((error) => {
        console.error("Error fetching users:", error);
      });
  }

  function setupEventListeners() {
    statusFilter.addEventListener("change", renderIssuedBooks);
    searchInput.addEventListener("input", renderIssuedBooks);

    document.querySelectorAll("th[data-sortable]").forEach((header) => {
      header.addEventListener("click", () => {
        const column = header.getAttribute("data-sortable");
        if (currentSortColumn === column) {
          sortDirection *= -1;
        } else {
          currentSortColumn = column;
          sortDirection = 1;
        }
        renderIssuedBooks();
      });
    });
  }

  function getBookTitle(bookId) {
    if (!window.booksData) return "Unknown Book";
    const book = window.booksData.find(
      (b) => b.bookID == bookId || b.id == bookId
    );
    return book ? book.title || book.Title || "Unknown Book" : "Unknown Book";
  }

  function getUserName(userId) {
    if (!window.allUsersData) return "Unknown User";
    const user = window.allUsersData.find(
      (u) => u.userID == userId || u.id == userId
    );
    return user ? user.name || "Unknown User" : "Unknown User";
  }

  function getUserEmail(userId) {
    if (!window.allUsersData) return null;
    const user = window.allUsersData.find(
      (u) => u.userID == userId || u.id == userId
    );
    return user ? user.email || null : null;
  }

  function renderIssuedBooks() {
    const statusFilterValue = statusFilter.value;
    const searchTerm = searchInput.value.toLowerCase();

    const userUserIds = window.usersData.map((user) => user.userID || user.id);

    let filteredRecords = allRecords.filter((record) => {
      const isUserTypeUser = userUserIds.includes(record.userID);
      if (!isUserTypeUser) return false;

      const recordStatus = record.status ? record.status.toLowerCase() : "";
      const matchesStatus =
        statusFilterValue === "all" ||
        recordStatus === statusFilterValue.toLowerCase();

      const bookTitle = getBookTitle(record.bookID).toLowerCase();
      const userName = getUserName(record.userID).toLowerCase();

      const matchesSearch =
        bookTitle.includes(searchTerm) ||
        userName.includes(searchTerm) ||
        (record.recordID && record.recordID.toString().includes(searchTerm));

      return matchesStatus && matchesSearch;
    });

    if (filteredRecords.length === 0) {
      issuedBooksTableBody.innerHTML = `
            <tr>
                <td colspan="7" class="text-center py-4">
                    <i class="bi bi-exclamation-circle fs-4"></i>
                    <p class="mb-0 mt-2">No records found matching your criteria</p>
                </td>
            </tr>
        `;
      return;
    }

    if (currentSortColumn) {
      filteredRecords.sort((a, b) => {
        let aValue, bValue;

        switch (currentSortColumn) {
          case "title":
            aValue = getBookTitle(a.bookID);
            bValue = getBookTitle(b.bookID);
            return aValue.localeCompare(bValue) * sortDirection;
          case "borrower":
            aValue = getUserName(a.userID);
            bValue = getUserName(b.userID);
            return aValue.localeCompare(bValue) * sortDirection;
          case "borrowDate":
            return (
              (new Date(a.borrowDate) - new Date(b.borrowDate)) * sortDirection
            );
          case "dueDate":
            return (new Date(a.dueDate) - new Date(b.dueDate)) * sortDirection;
          case "status":
            return a.status.localeCompare(b.status) * sortDirection;
          default:
            return 0;
        }
      });
    }

    issuedBooksTableBody.innerHTML = filteredRecords
      .map(
        (record) => `
      <tr>
        <td class="ps-4">${record.recordID}</td>
        <td>${getBookTitle(record.bookID)}</td>
        <td>${getUserName(record.userID)}</td>
        <td>${formatDate(record.borrowDate)}</td>
        <td>${formatDate(record.dueDate)}</td>
        <td>
          <span class="badge ${
            record.status === "Returned"
              ? "bg-success"
              : record.status === "Borrowed"
              ? "bg-warning text-dark"
              : "bg-danger text-white"
          }">
            ${record.status}
          </span>
        </td>
        <td class="pe-4 text-end">
          ${
            record.status === "Borrowed"
              ? `
            <button class="btn btn-sm btn-outline-success me-2 return-btn" data-id="${record.recordID}">
              <i class="bi bi-check-circle me-1"></i>Mark Returned
            </button>
          `
              : record.status === "Pending"
              ? `
            <button class="btn btn-sm btn-outline-primary me-2 email-btn" data-id="${record.recordID}" data-user-id="${record.userID}">
              <i class="bi bi-envelope me-1"></i>Send Email
            </button>
          `
              : ""
          }
          <button class="btn btn-sm btn-outline-danger delete-btn" data-id="${
            record.recordID
          }">
            <i class="bi bi-trash me-1"></i>Delete
          </button>
        </td>
      </tr>
    `
      )
      .join("");

    document.querySelectorAll(".return-btn").forEach((btn) => {
      btn.addEventListener("click", () => markAsReturned(btn.dataset.id));
    });

    document.querySelectorAll(".email-btn").forEach((btn) => {
      btn.addEventListener("click", () =>
        sendReminderEmail(btn.dataset.id, btn.dataset.userId)
      );
    });

    document.querySelectorAll(".delete-btn").forEach((btn) => {
      btn.addEventListener("click", () => deleteRecord(btn.dataset.id));
    });
  }

  function formatDate(dateString) {
    if (!dateString) return "N/A";
    const date = new Date(dateString);
    return date.toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
    });
  }

  function sendReminderEmail(recordId, userId) {
    const userEmail = getUserEmail(userId);
    if (!userEmail) {
      showAlert("User email not found", "danger");
      return;
    }

    if (confirm(`Send reminder email to ${userEmail}?`)) {
      setTimeout(() => {
        showAlert(`Reminder email sent to ${userEmail}`, "success");
      }, 1000);
    }
  }

  function markAsReturned(recordId) {
    if (confirm("Are you sure you want to mark this book as returned?")) {
      const recordIndex = allRecords.findIndex((r) => r.recordID == recordId);
      if (recordIndex === -1) return;

      const originalRecord = allRecords[recordIndex];
      const updatedRecord = {
        ...originalRecord,
        status: "Returned",
        returnDate: new Date().toISOString().split("T")[0],
      };

      allRecords[recordIndex] = updatedRecord;
      renderIssuedBooks();
      showAlert("Updating record...", "info");

      fetch(`${borrowRecordsApiUrl}/${recordId}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          Authorization: getAuthorization(),
        },
        body: JSON.stringify(updatedRecord),
      })
        .then((res) => {
          if (!res.ok) throw new Error("Update failed");
          return res.json();
        })
        .then(() => {
          const mergedRecord = {
            ...originalRecord,
          };
          allRecords[recordIndex] = mergedRecord;
          showAlert("Book marked as returned successfully", "success");

          updateBookAvailableCount(originalRecord.bookID, 1);
        })
        .catch((error) => {
          allRecords[recordIndex] = originalRecord;
          renderIssuedBooks();
          showAlert("Failed to update record: " + error.message, "danger");
        });
    }
  }

  function updateBookAvailableCount(bookId, increment) {
    if (!window.booksData || !bookId) return;

    const book = window.booksData.find(
      (b) => b.bookID == bookId || b.id == bookId
    );
    if (book) {
      const updatedCopies = (parseInt(book.availableCopies) || 0) + increment;
      fetch(`${booksApiUrl}/${book.bookID || book.id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        Authorization: getAuthorization(),
        body: JSON.stringify({ availableCopies: updatedCopies }),
      }).catch(console.error);
    }
  }

  function deleteRecord(recordId) {
    if (confirm("Are you sure you want to delete this record?")) {
      fetch(`${borrowRecordsApiUrl}/${recordId}`, {
        method: "DELETE",
        headers: {
          Authorization: getAuthorization(),
        },
      })
        .then((res) => {
          if (!res.ok) throw new Error("Delete failed");
          return fetchBorrowRecords();
        })
        .then(() => {
          renderIssuedBooks();
          showAlert("Record deleted successfully", "success");
        })
        .catch((error) => {
          console.error("Error deleting record:", error);
          showAlert("Failed to delete record", "danger");
        });
    }
  }

  function showAlert(message, type) {
    const existingAlert = document.querySelector(".alert");
    if (existingAlert) existingAlert.remove();

    const alertDiv = document.createElement("div");
    alertDiv.className = `alert alert-${type} alert-dismissible fade show fixed-top mx-auto mt-3`;
    alertDiv.style.maxWidth = "500px";
    alertDiv.style.zIndex = "1100";
    alertDiv.role = "alert";
    alertDiv.innerHTML = `
      ${message}
      <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    `;

    document.body.appendChild(alertDiv);
  }
</script>
